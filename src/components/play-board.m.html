<script type="module">
  import { defineComponent, onCleanup, reactive } from 'elii'
  import {
    blockWidth,
    blockHeight,
    blockOverlap,
    linePaddingSide,
    linePaddingTop,
    linePaddingBottom,
    findBlockById,
    isAddableBlocksToLine,
  } from '@/rule/block-utils.js'
  import { images } from '@/r.js'

  import './play-line.m.html'
  import './play-block.m.html'
  import './x-bg.m.html'

  export default defineComponent({
    tag: 'play-board',
    document: import.meta.document,
    props: {
      lines: /** @type {Line[]} */ ([]),
      onBlockMove: /** @type {(() => void) | null} */ (null),
    },
    setup(props) {
      const state = reactive({
        selectedBlockId: '',
        hoverLineId: '',
        dragInfo: /** @type {{ x: number, y: number, dx:number, dy:number, moving: boolean } | null} */ (null),
      })

      let oldSelectedBlockId = ''

      const linesMinX = props.lines.reduce((min, line) => Math.min(min, line.x), Infinity)
      const linesMinY = props.lines.reduce((min, line) => Math.min(min, line.y), Infinity)
      const linesMaxX = props.lines.reduce((max, line) => Math.max(max, line.x + blockWidth + linePaddingSide * 2), 0)
      const linesMaxY = props.lines.reduce((max, line) => {
        const lineHeight = blockHeight * line.size - blockOverlap * (line.size - 1) + linePaddingTop + linePaddingBottom
        return Math.max(max, line.y + lineHeight)
      }, 0)
      const boardWidth = linesMaxX + linesMinX
      const boardHeight = linesMaxY + linesMinY
      const boardScaleX = 100 / boardWidth
      const boardScaleY = 100 / boardHeight

      /**
       * 盤面外をクリックした場合、選択状態を解除する
       * @param {PointerEvent} e
       */
      const onGlobalPointerDown = (e) => {
        if (e.defaultPrevented) return
        state.selectedBlockId = ''
      }

      let requestId = 0
      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerMove = (e) => {
        const dragInfo = state.dragInfo
        if (dragInfo) {
          const dx = e.clientX - dragInfo.x
          const dy = e.clientY - dragInfo.y
          cancelAnimationFrame(requestId)
          requestId = requestAnimationFrame(() => {
            if (state.dragInfo) {
              state.dragInfo.dx = dx
              state.dragInfo.dy = dy
              state.dragInfo.moving ||= Math.sqrt(dx ** 2 + dy ** 2) > 10
            }
          })
        }
      }

      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerUp = (e) => {
        if (e.defaultPrevented) return
        state.dragInfo = null
      }

      addEventListener('pointerdown', onGlobalPointerDown)
      addEventListener('pointermove', onGlobalPointerMove)
      addEventListener('pointerup', onGlobalPointerUp)
      onCleanup(() => {
        removeEventListener('pointerdown', onGlobalPointerDown)
        removeEventListener('pointermove', onGlobalPointerMove)
        removeEventListener('pointerup', onGlobalPointerUp)
      })

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerDown = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        // 選択中のブロックを移動する
        moveSelectedBlockToLine(line)
        state.selectedBlockId = ''
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerEnter = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        state.hoverLineId = line.id
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerLeave = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        state.hoverLineId = ''
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerUp = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        if (state.dragInfo?.moving === false) {
          // 選択してその場で放した＝ただのクリック
          // 選択中のブロックの再クリックなら選択を解除する
          if (oldSelectedBlockId === state.selectedBlockId) {
            state.selectedBlockId = ''
          }
        } else {
          // 選択中のブロックがあれば移動する
          const moved = moveSelectedBlockToLine(line)
          if (moved) {
            state.selectedBlockId = ''
          }
        }

        state.dragInfo = null
      }

      /**
       * @param {Block} block
       * @param {PointerEvent} e
       */
      const onBlockPointerDown = (block, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        const { line, blockIndex } = findBlockById(props.lines, block.id)

        // ブロックに繋がる最も根本の同色ブロックを取得する
        for (let i = blockIndex - 1; i >= 0; i--) {
          const b = line.blocks.at(i)
          if (b?.color === block.color) block = b
          else break
        }

        // ブロックを選択中にする
        oldSelectedBlockId = state.selectedBlockId
        state.selectedBlockId = block.id
        state.hoverLineId = line.id
        state.dragInfo = { x: e.clientX, y: e.clientY, dx: 0, dy: 0, moving: false }
      }

      /**
       * @param {Block} block
       * @param {PointerEvent} e
       */
      const onBlockPointerEnter = (block, e) => {
        const { line } = findBlockById(props.lines, block.id)
        onLinePointerEnter(line, e)
      }

      /**
       * @param {Block} block
       * @param {PointerEvent} e
       */
      const onBlockPointerLeave = (block, e) => {
        const { line } = findBlockById(props.lines, block.id)
        onLinePointerLeave(line, e)
      }

      /**
       * @param {Block} block
       * @param {PointerEvent} e
       */
      const onBlockPointerUp = (block, e) => {
        const { line } = findBlockById(props.lines, block.id)
        onLinePointerUp(line, e)
      }

      /**
       * @param {Line} line
       */
      const moveSelectedBlockToLine = (line) => {
        // 選択中のブロックがそこへ移動可能なら移動する
        const selected = state.selectedBlockId ? findBlockById(props.lines, state.selectedBlockId) : null

        if (selected && isAddableBlocksToLine(line, selected.line, selected.blockIndex)) {
          const selectedBlocks = selected.line.blocks.slice(selected.blockIndex)
          line.blocks = [...line.blocks, ...selectedBlocks]
          selected.line.blocks = selected.line.blocks.slice(0, selected.blockIndex)

          props.onBlockMove?.()

          return true
        }

        return false
      }

      return {
        props,
        images,
        state,
        blocks: props.lines.flatMap((line) => line.blocks),
        blockWidth,
        blockHeight,
        blockOverlap,
        linePaddingSide,
        linePaddingTop,
        boardWidth,
        boardHeight,
        boardScaleX,
        boardScaleY,
        onLinePointerDown,
        onLinePointerUp,
        onLinePointerEnter,
        onLinePointerLeave,
        onBlockPointerDown,
        onBlockPointerUp,
        onBlockPointerEnter,
        onBlockPointerLeave,
      }
    },
  })
</script>

<template>
  <div class="board" data-style-aspect-ratio="`${boardWidth} / ${boardHeight}`">
    <div
      class="board-bg"
      data-style-background-position-y="`calc(100vh + ${linePaddingTop * boardScaleY}cqh)`"
      data-style-background-size="`${(blockWidth + linePaddingSide * 2) * boardScaleX * 2}cqw ${(blockHeight - blockOverlap) * boardScaleY * 2}cqh`"
    ></div>

    <template data-for="line in props.lines" data-key="line.id">
      <play-line
        data-prop-line="line"
        data-prop-lines="props.lines"
        data-prop-board-scale-x="boardScaleX"
        data-prop-board-scale-y="boardScaleY"
        data-prop-selected-block-id="state.selectedBlockId"
        data-prop-drag-info="state.dragInfo"
        data-prop-hover-line-id="state.hoverLineId"
        data-on-pointerdown="(e) => onLinePointerDown(line, e)"
        data-on-pointerup="(e) => onLinePointerUp(line, e)"
        data-on-pointerenter="(e) => onLinePointerEnter(line, e)"
        data-on-pointerleave="(e) => onLinePointerLeave(line, e)"
      ></play-line>
    </template>

    <template data-for="block in blocks" data-key="block.id">
      <play-block
        data-prop-block="block"
        data-prop-lines="props.lines"
        data-prop-board-scale-x="boardScaleX"
        data-prop-board-scale-y="boardScaleY"
        data-prop-selected-block-id="state.selectedBlockId"
        data-prop-drag-info="state.dragInfo"
        data-on-pointerdown="(e) => onBlockPointerDown(block, e)"
        data-on-pointerup="(e) => onBlockPointerUp(block, e)"
        data-on-pointerenter="(e) => onBlockPointerEnter(block, e)"
        data-on-pointerleave="(e) => onBlockPointerLeave(block, e)"
      ></play-block>
    </template>
  </div>
</template>

<style>
  :host {
    display: contents;
  }

  .board {
    position: relative;
    container-type: size;
    z-index: 1;
  }

  .board-bg {
    left: -100vw;
    top: -100vh;
    width: 200vw;
    height: 200vh;
    position: absolute;
    background-position-x: 100vw;
    background-image: url('/assets/board-bg.png');
    opacity: 0.06;
    z-index: 0;
    pointer-events: none;
  }
</style>
