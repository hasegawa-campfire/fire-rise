<script type="module">
  import { batch, defineComponent, onCleanup, reactive } from 'elii'
  import {
    blockWidth,
    blockHeight,
    blockOverlap,
    linePaddingSide,
    linePaddingTop,
    linePaddingBottom,
    lineWidth,
    calcLineHeight,
    isMovableBlock,
    moveBlock,
  } from '@/rule/board-utils.js'
  import { images, route, se } from '@/r.js'

  import './play-line.m.html'
  import './play-block.m.html'
  import './x-bg.m.html'

  export default defineComponent({
    tag: 'play-board',
    document: import.meta.document,
    props: {
      board: /** @type {Board} */ ({ lines: {}, blocks: {} }),
      onBlockMove: /** @type {(() => void) | null} */ (null),
    },
    setup(props) {
      const state = reactive({
        isReady: false,
        selectedBlockId: '',
        hoverLineId: '',
        dragInfo: /** @type {{ x: number, y: number, dx:number, dy:number, moving: boolean } | null} */ (null),
        refBoard: /** @type {Element | null} */ (null),
      })

      route.onReady(() => {
        state.isReady = true
      })

      let oldSelectedBlockId = ''

      const lines = Object.values(props.board.lines)
      const linesMinX = lines.reduce((min, line) => Math.min(min, line.x), Infinity)
      const linesMinY = lines.reduce((min, line) => Math.min(min, line.y), Infinity)
      const linesMaxX = lines.reduce((max, line) => Math.max(max, line.x + blockWidth + linePaddingSide * 2), 0)
      const linesMaxY = lines.reduce((max, line) => {
        const lineHeight = blockHeight * line.size - blockOverlap * (line.size - 1) + linePaddingTop + linePaddingBottom
        return Math.max(max, line.y + lineHeight)
      }, 0)
      const boardWidth = linesMaxX + linesMinX
      const boardHeight = linesMaxY + linesMinY
      const boardScaleX = 100 / boardWidth
      const boardScaleY = 100 / boardHeight

      const restart = () => {
        state.isReady = false
        window.requestAnimationFrame(() => {
          state.isReady = true
        })
      }

      /**
       * @param {number} clientX
       * @param {number} clientY
       * @returns {Line | null}
       */
      const lineFromPoint = (clientX, clientY) => {
        const boardRect = state.refBoard?.getBoundingClientRect()
        if (boardRect) {
          const pointerX = ((clientX - boardRect.left) / boardRect.width) * boardWidth
          const pointerY = ((clientY - boardRect.top) / boardRect.height) * boardHeight

          for (const line of Object.values(props.board.lines)) {
            const lineH = calcLineHeight(line.size)
            if (
              pointerX >= line.x &&
              pointerX <= line.x + lineWidth &&
              pointerY >= line.y &&
              pointerY <= line.y + lineH
            ) {
              return line
            }
          }
        }
        return null
      }

      /**
       * 盤面外をクリックした場合、選択状態を解除する
       * @param {PointerEvent} e
       */
      const onGlobalPointerDown = (e) => {
        if (e.defaultPrevented) return
        state.selectedBlockId = ''
      }

      let requestId = 0
      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerMove = (e) => {
        const dragInfo = state.dragInfo
        if (dragInfo) {
          const dx = e.clientX - dragInfo.x
          const dy = e.clientY - dragInfo.y
          cancelAnimationFrame(requestId)
          requestId = requestAnimationFrame(() => {
            if (state.dragInfo) {
              state.dragInfo.dx = dx
              state.dragInfo.dy = dy
              state.dragInfo.moving ||= Math.sqrt(dx ** 2 + dy ** 2) > 10
              state.hoverLineId = lineFromPoint(e.clientX, e.clientY)?.id ?? ''
            }
          })
        }
      }

      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerUp = (e) => {
        if (e.defaultPrevented) return

        batch(() => {
          if (state.dragInfo?.moving === false) {
            // 選択してその場で放した＝ただのクリック
            // 選択中のブロックの再クリックなら選択を解除する
            if (oldSelectedBlockId === state.selectedBlockId) {
              state.selectedBlockId = ''
            }
          } else if (state.dragInfo && state.hoverLineId) {
            // 選択中のブロックがあれば移動する
            moveSelectedBlockToLine(state.hoverLineId)
            state.selectedBlockId = ''
          }

          state.dragInfo = null
          state.hoverLineId = ''
        })
      }

      addEventListener('pointerdown', onGlobalPointerDown)
      addEventListener('pointermove', onGlobalPointerMove)
      addEventListener('pointerup', onGlobalPointerUp)
      onCleanup(() => {
        removeEventListener('pointerdown', onGlobalPointerDown)
        removeEventListener('pointermove', onGlobalPointerMove)
        removeEventListener('pointerup', onGlobalPointerUp)
      })

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerDown = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        // 選択中のブロックを移動する
        moveSelectedBlockToLine(line)
        state.selectedBlockId = ''
      }

      /**
       * @param {Block} block
       * @param {PointerEvent} e
       */
      const onBlockPointerDown = (block, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        const line = props.board.lines[block.lineId]

        // ブロックに繋がる最も根本の同色ブロックを取得する
        for (let i = block.index - 1; i >= 0; i--) {
          const b = props.board.blocks[line.blockIds[i]]
          if (b.color === block.color) block = b
          else break
        }

        if (state.selectedBlockId !== block.id) {
          se.move.play()
        }

        // ブロックを選択中にする
        oldSelectedBlockId = state.selectedBlockId
        state.selectedBlockId = block.id
        state.hoverLineId = line.id
        state.dragInfo = { x: e.clientX, y: e.clientY, dx: 0, dy: 0, moving: false }
      }

      /**
       * @param {Line | string} line
       */
      const moveSelectedBlockToLine = (line) => {
        // 選択中のブロックがそこへ移動可能なら移動する
        if (state.selectedBlockId && isMovableBlock(props.board, line, state.selectedBlockId)) {
          moveBlock(props.board, line, state.selectedBlockId)
          props.onBlockMove?.()
          return true
        }

        return false
      }

      return {
        props,
        images,
        state,
        blockWidth,
        blockHeight,
        blockOverlap,
        linePaddingSide,
        linePaddingTop,
        boardWidth,
        boardHeight,
        boardScaleX,
        boardScaleY,
        onLinePointerDown,
        onBlockPointerDown,
        $expose: {
          restart,
        },
      }
    },
  })
</script>

<template>
  <div class="board" data-style-aspect-ratio="`${boardWidth} / ${boardHeight}`" data-ref="state.refBoard">
    <div
      class="board-bg"
      data-style-background-position-y="`calc(100vh + ${linePaddingTop * boardScaleY}cqh)`"
      data-style-background-size="`${(blockWidth + linePaddingSide * 2) * boardScaleX * 2}cqw ${(blockHeight - blockOverlap) * boardScaleY * 2}cqh`"
    ></div>

    <template data-for="line in Object.values(props.board.lines)" data-key="line.id">
      <play-line
        data-prop-line-id="line.id"
        data-prop-board="props.board"
        data-prop-board-scale-x="boardScaleX"
        data-prop-board-scale-y="boardScaleY"
        data-prop-selected-block-id="state.selectedBlockId"
        data-prop-drag-info="state.dragInfo"
        data-prop-hover-line-id="state.hoverLineId"
        data-on-pointerdown="(e) => onLinePointerDown(line, e)"
      ></play-line>
    </template>

    <template data-for="block in Object.values(props.board.blocks)" data-key="block.id">
      <play-block
        data-prop-block-id="block.id"
        data-prop-board="props.board"
        data-prop-board-scale-x="boardScaleX"
        data-prop-board-scale-y="boardScaleY"
        data-prop-is-ready="state.isReady"
        data-prop-selected-block-id="state.selectedBlockId"
        data-prop-drag-info="state.dragInfo"
        data-on-pointerdown="(e) => onBlockPointerDown(block, e)"
      ></play-block>
    </template>
  </div>
</template>

<style>
  :host {
    display: contents;
  }

  .board {
    position: relative;
    container-type: size;
    z-index: 1;
  }

  .board-bg {
    left: -100vw;
    top: -100vh;
    width: 200vw;
    height: 200vh;
    position: absolute;
    background-position-x: 100vw;
    background-image: var(--images-board-bg);
    opacity: 0.06;
    z-index: 0;
    pointer-events: none;
  }
</style>
