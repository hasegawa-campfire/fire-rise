<script type="module">
  import { createMemo, defineComponent, onCleanup, reactive } from 'elii'
  import {
    findBlockById,
    getCompletionRate,
    isAddableBlocksToLine,
    isGoalState,
    isStuckState,
  } from '@/rule/block-utils.js'
  import { images } from '@/r.js'
  import {
    blockWidth,
    blockHeight,
    blockOverlap,
    linePaddingSide,
    linePaddingTop,
    linePaddingBottom,
  } from '@/rule/level.js'

  import './x-bg.m.html'

  export default defineComponent({
    tag: 'play-board',
    document: import.meta.document,
    props: {
      lines: /** @type {Line[]} */ ([]),
      onBlockMove: /** @type {(() => void) | null} */ (null),
    },
    setup(props) {
      const state = reactive({
        selectedBlockId: '',
        lastSelectedBlockId: '',
        selectedBlockPopup: false,
        hoverLineId: '',
        dragInfo: /** @type {{ x: number, y: number, dx:number, dy:number, moving: boolean } | null} */ (null),
      })

      const linesMinX = props.lines.reduce((min, line) => Math.min(min, line.x), Infinity)
      const linesMinY = props.lines.reduce((min, line) => Math.min(min, line.y), Infinity)
      const linesMaxX = props.lines.reduce((max, line) => Math.max(max, line.x + blockWidth + linePaddingSide * 2), 0)
      const linesMaxY = props.lines.reduce((max, line) => {
        const lineHeight = blockHeight * line.size - blockOverlap * (line.size - 1) + linePaddingTop + linePaddingBottom
        return Math.max(max, line.y + lineHeight)
      }, 0)
      const boardWidth = linesMaxX + linesMinX
      const boardHeight = linesMaxY + linesMinY
      const boardScaleX = 100 / boardWidth
      const boardScaleY = 100 / boardHeight

      /**
       * 盤面外をクリックした場合、選択状態を解除する
       * @param {PointerEvent} e
       */
      const onGlobalPointerDown = (e) => {
        if (e.defaultPrevented) return
        if (state.selectedBlockId) state.lastSelectedBlockId = state.selectedBlockId
        state.selectedBlockId = ''
      }

      let requestId = 0
      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerMove = (e) => {
        const dragInfo = state.dragInfo
        if (dragInfo) {
          const dx = e.clientX - dragInfo.x
          const dy = e.clientY - dragInfo.y
          cancelAnimationFrame(requestId)
          requestId = requestAnimationFrame(() => {
            if (state.dragInfo) {
              state.dragInfo.dx = dx
              state.dragInfo.dy = dy
              state.dragInfo.moving ||= Math.sqrt(dx ** 2 + dy ** 2) > 10
            }
          })
        }
      }

      /**
       * @param {PointerEvent} e
       */
      const onGlobalPointerUp = (e) => {
        if (e.defaultPrevented) return
        if (state.selectedBlockId) state.lastSelectedBlockId = state.selectedBlockId
        state.selectedBlockId = ''
        state.dragInfo = null
      }

      addEventListener('pointerdown', onGlobalPointerDown)
      addEventListener('pointermove', onGlobalPointerMove)
      addEventListener('pointerup', onGlobalPointerUp)
      onCleanup(() => removeEventListener('pointerdown', onGlobalPointerDown))
      onCleanup(() => removeEventListener('pointermove', onGlobalPointerMove))
      onCleanup(() => removeEventListener('pointerup', onGlobalPointerUp))

      /**
       * @param {Line} line
       */
      const isSelectableLine = (line) => {
        const selected = findBlockById(props.lines, state.selectedBlockId)
        return !!selected && isAddableBlocksToLine(line, selected.line, selected.blockIndex)
      }

      const blockInfos = props.lines.flatMap((line) => {
        return line.blocks.map((block) => {
          return createMemo(() => {
            for (const [lineIndex, line] of props.lines.entries()) {
              let selected = false
              let prevColor = ''
              let zIndex = 10
              let bgZIndex = zIndex
              let unitBgZIndex = 0
              let unitHead = false
              let delay = 0
              for (const [blockIndex, b] of line.blocks.entries()) {
                delay++
                if (state.selectedBlockId === b.id) {
                  selected = true
                  zIndex += 100
                  bgZIndex = zIndex
                  delay = 1
                }
                if (state.lastSelectedBlockId === b.id) {
                  delay = 1
                }
                if (prevColor !== b.color) {
                  zIndex += 10
                  unitBgZIndex = zIndex - 9
                }
                unitHead = prevColor !== b.color
                prevColor = b.color
                zIndex += unitHead ? 1 : -1
                if (block.id === b.id) {
                  return {
                    line,
                    lineIndex,
                    block,
                    blockIndex,
                    selected,
                    unitHead,
                    zIndex,
                    bgZIndex,
                    unitBgZIndex,
                    delay,
                  }
                }
              }
            }
            throw new Error('block not found')
          })
        })
      })

      /**
       * @param {Block} block
       * @param {number} blockIndex
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onBlockPointerDown = (block, blockIndex, line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        // ブロックに繋がる最も根本の同色ブロックを取得する
        for (let i = blockIndex - 1; i >= 0; i--) {
          const b = line.blocks.at(i)
          if (b?.color === block.color) block = b
          else break
        }

        // ブロックを選択中にする
        if (state.selectedBlockId !== block.id) {
          state.selectedBlockId = block.id
          state.hoverLineId = line.id
          state.selectedBlockPopup = false
        }
        state.dragInfo = { x: e.clientX, y: e.clientY, dx: 0, dy: 0, moving: false }
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerDown = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        // 選択中のブロックを移動する
        moveSelectedBlockToLine(line)
        if (state.selectedBlockId) state.lastSelectedBlockId = state.selectedBlockId
        state.selectedBlockId = ''
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerEnter = (line, e) => {
        state.hoverLineId = line.id
      }

      /**
       * @param {Line} line
       * @param {PointerEvent} e
       */
      const onLinePointerUp = (line, e) => {
        if (e.defaultPrevented) return
        e.preventDefault()

        if (state.dragInfo?.moving === false) {
          // 選択してその場で放した＝ただのクリック
          if (!state.selectedBlockPopup) {
            state.selectedBlockPopup = true
          } else {
            state.selectedBlockPopup = false
            if (state.selectedBlockId) state.lastSelectedBlockId = state.selectedBlockId
            state.selectedBlockId = ''
          }
        } else {
          // 選択中のブロックがあれば移動する
          const moved = moveSelectedBlockToLine(line)
          if (moved) {
            if (state.selectedBlockId) state.lastSelectedBlockId = state.selectedBlockId
            state.selectedBlockId = ''
          } else {
            state.selectedBlockPopup = true
          }
        }

        state.dragInfo = null
      }

      /**
       * @param {Line} line
       */
      const moveSelectedBlockToLine = (line) => {
        // 選択中のブロックがそこへ移動可能なら移動する
        const selected = findBlockById(props.lines, state.selectedBlockId)

        if (selected && isAddableBlocksToLine(line, selected.line, selected.blockIndex)) {
          const selectedBlocks = selected.line.blocks.slice(selected.blockIndex)
          line.blocks = [...line.blocks, ...selectedBlocks]
          selected.line.blocks = selected.line.blocks.slice(0, selected.blockIndex)

          props.onBlockMove?.()

          return true
        }

        return false
      }

      return {
        props,
        images,
        state,
        blockWidth,
        blockHeight,
        blockOverlap,
        linePaddingSide,
        linePaddingTop,
        linePaddingBottom,
        boardWidth,
        boardHeight,
        boardScaleX,
        boardScaleY,
        blockInfos,
        onBlockPointerDown,
        onLinePointerDown,
        onLinePointerUp,
        onLinePointerEnter,
        isSelectableLine,
      }
    },
  })
</script>

<template>
  <div class="board" data-style-aspect-ratio="`${boardWidth} / ${boardHeight}`">
    <div
      class="board-bg"
      data-style-background-position-y="`calc(100vh + ${linePaddingTop * boardScaleY}cqh)`"
      data-style-background-size="`${(blockWidth + linePaddingSide * 2) * boardScaleX * 2}cqw ${(blockHeight - blockOverlap) * boardScaleY * 2}cqh`"
    ></div>

    <template data-for="line, lineIndex in props.lines" data-key="line.id">
      <div
        class="line"
        data-class-selectable="isSelectableLine(line)"
        data-class-droppable="state.dragInfo && state.hoverLineId === line.id"
        data-style-left="`${line.x * boardScaleX}cqw`"
        data-style-top="`${line.y * boardScaleY}cqh`"
        data-style-width="`${(blockWidth + linePaddingSide * 2) * boardScaleX}cqw`"
        data-style-height="`${(blockHeight * line.size - blockOverlap * (line.size - 1) + linePaddingTop + linePaddingBottom) * boardScaleY}cqh`"
        data-on-pointerdown="(e) => onLinePointerDown(line, e)"
        data-on-pointerup="(e) => onLinePointerUp(line, e)"
        data-on-pointerenter="(e) => onLinePointerEnter(line, e)"
      >
        <div class="line-bg"></div>
        <div class="line-shadow"></div>
        <div
          class="line-bottom"
          data-class-even="lineIndex % 2 === 0"
          data-style-height="`${linePaddingBottom * boardScaleY}cqh`"
        ></div>
      </div>
    </template>

    <template data-for="info in blockInfos" data-key="info.block.id">
      <div
        class="block"
        data-class-drag="info.selected && !!state.dragInfo"
        data-style-color="info.block.color"
        data-style-left="`calc(${(info.line.x + linePaddingSide) * boardScaleX}cqw + ${info.selected && state.dragInfo?.dx || 0}px)`"
        data-style-top="`calc(${(info.line.y + linePaddingTop + (blockHeight - blockOverlap) * (info.line.size - info.blockIndex - 1) - (info.selected && state.selectedBlockPopup ? blockOverlap * 0.5 : 0)) * boardScaleY}cqh + ${info.selected && state.dragInfo?.dy || 0}px)`"
        data-style-width="`${blockWidth * boardScaleX}cqw`"
        data-style-height="`${blockHeight * boardScaleY}cqh`"
        data-style-transition-duration="`${info.delay * 90 + 100}ms`"
        data-on-pointerdown="(e) => onBlockPointerDown(info.block, info.blockIndex, info.line, e)"
        data-on-pointerup="(e) => onLinePointerUp(info.line, e)"
        data-on-pointerenter="(e) => onLinePointerEnter(info.line, e)"
      >
        <img
          class="block-image"
          data-prop-src="images.takibi.leg.white"
          data-style-z-index="info.bgZIndex"
          data-prop-hidden="info.blockIndex > 0"
        />
        <img
          class="block-image selected"
          data-prop-src="images.takibi.leg.orange"
          data-style-z-index="info.bgZIndex"
          data-prop-hidden="info.blockIndex > 0 || info.selected || !state.selectedBlockId"
        />
        <img class="block-image" data-prop-src="images.takibi.bg.white" data-style-z-index="info.bgZIndex" />
        <img
          class="block-image selected"
          data-prop-src="images.takibi.bg.orange"
          data-style-z-index="info.bgZIndex"
          data-prop-hidden="info.selected || !state.selectedBlockId"
        />
        <img
          class="block-image"
          data-prop-src="images.takibi.leg.black"
          data-style-z-index="info.unitBgZIndex"
          data-prop-hidden="info.blockIndex > 0"
        />
        <img class="block-image" data-prop-src="images.takibi.bg.black" data-style-z-index="info.unitBgZIndex" />
        <img
          class="block-image"
          data-prop-src="images.takibi.body[info.block.color]"
          data-style-z-index="info.zIndex"
        />
        <template data-if="info.unitHead">
          <img class="block-image" data-prop-src="images.takibi.face" data-style-z-index="info.zIndex" />
        </template>
      </div>
    </template>
  </div>
</template>

<style>
  :host {
    display: contents;
  }

  [hidden] {
    display: none !important;
  }

  .board {
    position: relative;
    container-type: size;
    z-index: 1;
  }

  .board-bg {
    left: -100vw;
    top: -100vh;
    width: 200vw;
    height: 200vh;
    position: absolute;
    background-position-x: 100vw;
    background-image: url('/assets/board-bg.png');
    opacity: 0.06;
    z-index: 0;
    pointer-events: none;
  }

  .line {
    position: absolute;
    z-index: 0;
  }

  .line-bg {
    position: absolute;
    inset: 0 8px 0;
    background-color: #0003;
    border: 4px solid #0002;
    border-radius: 999px 999px 0 0;

    .selectable & {
      /* background-color: #fff2; */
    }

    .selectable.droppable & {
      background-color: #fff6;
    }
  }

  .line-shadow {
    position: absolute;
    inset: 16px 24px 0;
    background-color: #0002;
    border-radius: 999px 999px 0 0;
  }

  .line-bottom {
    position: absolute;
    inset: auto 4px 0;
    border: 4px solid #5d1a00;
    border-radius: 2px;
    background-color: #921400;
    background-image: linear-gradient(to bottom, #0002, #0002 50%, transparent 50%, transparent);
    box-sizing: border-box;

    &.even {
      background-color: #bd1900;
    }
  }

  .block {
    position: absolute;
    aspect-ratio: 1;
    transition-property: left, top;
    transition-timing-function: cubic-bezier(0.34, 1.56, 0.64, 1);

    &.drag {
      pointer-events: none;
    }
  }

  .block-image {
    position: absolute;
    left: 0;
    width: 100%;
    top: 50%;
    transform: translateY(-50%);

    &.selected {
      /* animation: block-image-selected-animation 1s steps(2, jump-none) infinite; */
    }
  }

  @keyframes block-image-selected-animation {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }
</style>
