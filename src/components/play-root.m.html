<script type="module">
  import { defineComponent, onCleanup, reactive, toRaw } from 'elii'
  import { cloneBoard, getCompletionRate, isGoalState, isStuckState } from '@/rule/board-utils.js'
  import { route, runtime, icons, prefs, bgm, se, session } from '@/r.js'
  import { getNextLevel, levels } from '@/rule/level.js'

  import './x-header.m.html'
  import './x-icon.m.html'
  import './x-button.m.html'
  import './x-bg.m.html'
  import './x-overlay.m.html'
  import './x-text.m.html'
  import DialogHelp from './dialog-help.m.html'
  import DialogConfirm from './dialog-confirm.m.html'
  import PlayBoard from './play-board.m.html'

  export default defineComponent({
    tag: 'play-root',
    document: import.meta.document,
    setup() {
      runtime.result = null
      let failureTimeoutId = 0

      onCleanup(() => {
        window.clearTimeout(failureTimeoutId)
        failureTimeoutId = 0
      })

      const level = levels.find((level) => level.id === route.state.levelId)
      if (!level) throw Error('level not found')

      if (!prefs.levelStats[level.id]) {
        prefs.levelStats[level.id] = {
          wins: 0,
          streak: 0,
          highestStreak: 0,
        }
      }

      const levelStats = prefs.levelStats[level.id]

      if (session.startAt !== route.state.startAt) {
        session.startAt = route.state.startAt
        session.boardhistory = null
        session.streak = null
      }

      let boardhistory = /** @type {Board[]} */ ([])

      if (session.boardhistory) {
        boardhistory = toRaw(session.boardhistory, true).map(cloneBoard)
      }

      if (boardhistory.length === 0) {
        boardhistory = [level.createBoard(null)]
        session.boardhistory = boardhistory.map(cloneBoard)
      }

      if (session.streak === null) {
        session.streak = levelStats.streak
      }

      levelStats.streak = 0

      const state = reactive({
        board: cloneBoard(boardhistory[boardhistory.length - 1]),
        completionRate: getCompletionRate(boardhistory[boardhistory.length - 1]),
        isFirstMove: boardhistory.length === 1,
        isVisibleLevelStats: levelStats.wins > 0,
        refConfirm: /** @type {DialogConfirm | null} */ (null),
        refHelp: /** @type {DialogHelp | null} */ (null),
        refPlayBoard: /** @type {PlayBoard | null} */ (null),
      })

      route.onReady(() => {
        bgm.play.play(0.7)

        if (level.silentHelpPageId && prefs.seenHelps[level.silentHelpPageId] == null) {
          prefs.seenHelps[level.silentHelpPageId] = false
        }

        if (level.helpPageId && !prefs.seenHelps[level.helpPageId]) {
          state.refHelp?.open([level.helpPageId])
        }
      })

      const confirmGoToTitle = () => {
        if (runtime.result === 'success') {
          goToTitle()
        } else {
          state.refConfirm?.open('タイトルに\nもどりますか？', goToTitle)
        }
      }

      const goToTitle = () => {
        let levelId = level.id

        // ゲームクリアで、次のレベルが未クリアならそれをフォーカスする
        if (runtime.result === 'success') {
          const nextLevel = getNextLevel(level)
          if (nextLevel && !(prefs.levelStats[nextLevel.id]?.wins > 0)) {
            levelId = nextLevel.id
          }
        }

        route.pushState({ page: 'title', focusLevelId: levelId })
      }

      const confirmRestart = () => {
        if (runtime.result === 'success') {
          restart()
        } else {
          state.refConfirm?.open('あたらしいゲームを\nはじめますか？', restart)
        }
      }

      const restart = () => {
        if (runtime.result !== 'success') levelStats.streak = 0
        runtime.result = null
        window.clearTimeout(failureTimeoutId)
        failureTimeoutId = 0

        boardhistory = [level.createBoard(null)]
        session.boardhistory = boardhistory.map(cloneBoard)
        session.streak = levelStats.streak
        levelStats.streak = 0

        state.board = cloneBoard(boardhistory[0])
        state.completionRate = getCompletionRate(boardhistory[0])
        state.isFirstMove = true
        state.isVisibleLevelStats = levelStats.wins > 0
        state.refPlayBoard?.restart()
      }

      const undo = () => {
        runtime.result = null
        window.clearTimeout(failureTimeoutId)
        failureTimeoutId = 0

        boardhistory.pop()
        const board = boardhistory.at(-1)
        if (!board) throw Error('board not found')

        state.board = cloneBoard(board)
        state.completionRate = getCompletionRate(board)
        state.isFirstMove = boardhistory.length === 1
      }

      const onBlockMove = () => {
        if (runtime.result === 'success') return

        state.isFirstMove = false
        boardhistory.push(cloneBoard(toRaw(state.board, true)))
        session.boardhistory = boardhistory.map(cloneBoard)

        if (runtime.result || failureTimeoutId) return

        if (isGoalState(state.board)) {
          state.completionRate = 1
          runtime.result = 'success'
          levelStats.wins++
          levelStats.streak = (session.streak ?? 0) + 1
          session.streak = null
          session.boardhistory = null

          if (levelStats.streak > levelStats.highestStreak) {
            levelStats.highestStreak = levelStats.streak
          }
          se.clear.play()
        } else if (isStuckState(state.board)) {
          state.completionRate = -1
          runtime.result = 'failure'
        } else {
          state.completionRate = getCompletionRate(state.board)
        }
      }

      return {
        icons,
        session,
        runtime,
        state,
        level,
        levelStats,
        helpPageId: (level.helpPageId || level.silentHelpPageId) ?? 'basic',
        confirmGoToTitle,
        confirmRestart,
        undo,
        onBlockMove,
      }
    },
  })
</script>

<template>
  <x-header data-prop-help-page-id="helpPageId">
    <x-button slot="left" shadow data-on-click="confirmGoToTitle">
      <x-icon data-class-blink="runtime.result === 'success'" data-prop-svg-url="icons.back"></x-icon>
    </x-button>
    <div slot="center" class="level-info" data-class-visible="!state.isVisibleLevelStats">
      <div class="level-display-id" data-text="level.displayId"></div>
      <x-text class="level-name" data-prop-value="level.name"></x-text>
    </div>
    <div slot="right" class="level-stats" data-class-visible="state.isVisibleLevelStats">
      <div class="level-stats-name">Wins:</div>
      <div class="level-stats-value" data-text="levelStats.wins"></div>
      <div class="level-stats-name">Streak:</div>
      <div class="level-stats-value" data-text="session.streak ?? levelStats.streak"></div>
    </div>
    <x-button slot="right" shadow data-on-click="confirmRestart">
      <x-icon data-class-blink="runtime.result === 'success'" data-prop-svg-url="icons.restart"></x-icon>
    </x-button>
    <x-button
      slot="right"
      shadow
      data-on-click="undo"
      data-prop-inert="state.isFirstMove || runtime.result === 'success'"
    >
      <x-icon
        data-prop-svg-url="icons.undo"
        data-prop-disabled="state.isFirstMove || runtime.result === 'success'"
      ></x-icon>
    </x-button>
  </x-header>

  <x-bg
    data-prop-particle-level="state.completionRate < 0 ? 0 : state.completionRate ** 2 * 0.8 + 0.2"
    data-class="runtime.result"
  >
    <div class="bg-overlay" data-class-active="runtime.result === 'success'"></div>

    <div class="content">
      <play-board
        data-prop-board="state.board"
        data-prop-on-block-move="onBlockMove"
        data-ref="state.refPlayBoard"
      ></play-board>
    </div>
  </x-bg>

  <div class="flash-overlay" data-class-active="runtime.result === 'success'"></div>

  <x-overlay class="success-overlay">
    <x-text class="success-text" data-class-active="runtime.result === 'success'" value="VICTORY" shadow></x-text>
  </x-overlay>

  <dialog-confirm data-ref="state.refConfirm"></dialog-confirm>
  <dialog-help data-ref="state.refHelp"></dialog-help>
</template>

<style>
  :host {
    display: block;
    overflow: hidden;
  }

  [hidden] {
    display: none !important;
  }

  x-bg {
    &.success::part(bg) {
      filter: brightness(1.2);
    }

    &.failure::part(bg) {
      filter: grayscale(0.5);
    }
  }

  .bg-overlay {
    position: absolute;
    inset: 0;
    z-index: -1;
    background: #fff3;
    opacity: 0;
    will-change: opacity;

    &.active {
      animation: blink 1s infinite alternate;
    }
  }

  @keyframes blink {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }

  .content {
    padding: calc(50px + 10cqw) 0 0;
  }

  x-icon.blink {
    animation: icon-blink 2s steps(2, jump-none) infinite;
  }

  @keyframes icon-blink {
    0% {
      color: gold;
      --wave-color: #fff;
    }
    100% {
      color: darkorange;
      --wave-color: #ffcc88;
    }
  }

  .level-info {
    position: relative;
    white-space: nowrap;

    @media (width <= 420px) {
      &:not(.visible) {
        display: none;
      }
    }
  }

  .level-display-id {
    position: absolute;
    top: calc(var(--border-width) * -1);
    left: 50%;
    transform: translate(-50%, -100%);
    font-size: 12px;
    color: #fff;
    text-align: center;
    filter: drop-shadow(0px 3px 0 #0002);

    @media (width <= 520px) {
      font-size: 11px;
    }

    @media (width <= 375px) {
      font-size: 10px;
    }
  }

  .level-name {
    font-size: 24px;
    font-weight: 900;
    width: fit-content;
    margin: 0 auto;
    filter: drop-shadow(0px 3px 0 #0002);

    @media (width <= 600px) {
      font-size: 22px;
    }

    @media (width <= 520px) {
      font-size: 4cqw;
    }
  }

  .level-stats {
    color: #fff;
    font-size: 12px;
    display: grid;
    grid-template-columns: auto auto;
    gap: 0 4px;
    justify-items: end;
    filter: drop-shadow(0px 3px 0 #0002);

    &:not(.visible) {
      display: none;
    }

    @media (width <= 520px) {
      font-size: 11px;
    }

    @media (width <= 375px) {
      font-size: 10px;
    }
  }

  .flash-overlay {
    position: fixed;
    inset: 0;
    background: #fffc;
    opacity: 0;
    will-change: opacity;
    z-index: 10000;
    pointer-events: none;

    &.active {
      animation: flash 2s ease-out;
    }
  }

  @keyframes flash {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  .success-overlay {
    pointer-events: none;
  }

  .success-text {
    opacity: 0;
    font-size: calc(10px + 5cqw);

    &.active {
      transition: opacity 0.5s ease-out;
      opacity: 1;
    }
  }
</style>
